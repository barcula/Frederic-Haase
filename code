
size(500, 800)
background(255)
image_names = ["image1.png","image2.png"]
images = []
for path in image_names:
    images.append(loadImage(path))
    print path
npoints = 20 #Number of dabs
fleckx = []  # position der ellipsen horizontal
flecky = []  # position der ellipsen vertikal
a = []#halbachsen ellipsen horizontal
b = []#halbachsen ellipsen vertikal
punktex = []  # position der schwarzen flecken horizontal
punktey = []  # position der schwarzen flecken vertikal
for i in range(0, npoints):
    # es wird gewürfelt in welchem abstand c vom ellipsenmittelpunkt die lila flecken gemalt werden sollen
    c = random(50,70)
    # die größe "d" der schwarzen punkte wird gewüfelt
    d = random(15,23)

    # horizontale position der ellipsen wird gewürfelt
    fleckx.append(random(width))
    # vertikale position der ellipsen wird gewürfelt
    flecky.append(random(height))
 
    # horizontale halbachse der ellipsen wird gewürfelt
    a.append(random(40, 50))
    # vertikale halbachse der ellipsen wird gewürfelt
    b.append(random(40, 50))

    strokeWeight(0.2)
    noFill()
    # ellipsen werden gezeichnet
    ellipse(fleckx[i], flecky[i], 2 * a[i], 2 * b[i])

    # hier wird eines der beiden lila fleckmuster ausgewählt und dann in bezug zum ellipsenmittelpunkt gemahlt, immer rechts untendrunter, warum auch immer. 
    img = image(images[int(random(0, len(images)))],
                fleckx[i], flecky[i], c, c)
    
    # hier wird eine horizontale position für den schwarzen fleck gewürfelt,
    # erlaubt sind werte zwischen ellipsenposition fleckx - ellipsenbreite a bis ellipsenposition fleckx + ellipsenbreite a
    punktex.append(random(fleckx[i] - a[i], fleckx[i] + a[i]))
    
    # mit if wird nun entschieden ob man die obere oder die untere hälfte der ellipse als vertikale positionsmöglichkeit für den schwarzen fleck wählt
    # danach wird y dem zu x entsprechenden wert auf der oberen oder unteren hälfte der ellipse zugewiesen
    # y erhält man aus der ellipsengleichung x^2/a^2 + y^2/b^2 = 1, wobei man fleckx und flecky als referenzpunkt wählt, daher auch "+flecky[i]" und "punktex[i]-fleckx[i]"
    # die zwei zeilen in if / else unterscheiden sich auch nur durch ein minus. 
    if (int(random(0, 2)) == 1):
        punktey.append((b[i] ** 2 - (b[i] ** 2 / a[i] ** 2)
                        * (punktex[i] - fleckx[i]) ** 2) ** 0.5 + flecky[i])
    else:
        punktey.append(-(b[i] ** 2 - (b[i] ** 2 / a[i] ** 2)
                         * (punktex[i] - fleckx[i]) ** 2) ** 0.5 + flecky[i])
    # hier werden die schwarzen flecken gemalt 
    fill(random(0))                        
    ellipse(punktex[i], punktey[i], d, d)

    #hier werden nun alle der schwarzen flecken nacheinander mit einer linie verbunden, geht nur falls es mehr als einen fleck gibt, daher i>0
    if (i > 0):
        strokeWeight(1.5) 
        color(250)
        line(punktex[i-1], punktey[i-1 ], punktex[i], punktey[i])
